
// This gives the service worker access to all the APIs it needs
// to self-install and be ready for use.
if (typeof self === "undefined") {
    var self = this;
}

// Ensure Workbox is loaded
try {
    importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');
} catch (e) {
    console.error('Workbox could not be loaded.', e);
}


if (workbox) {
    console.log(`Yay! Workbox is loaded ðŸŽ‰`);

    const { registerRoute } = workbox.routing;
    const { CacheFirst, NetworkFirst, StaleWhileRevalidate } = workbox.strategies;
    const { CacheableResponsePlugin } = workbox.cacheableResponse;
    const { ExpirationPlugin } = workbox.expiration;
    const { precacheAndRoute } = workbox.precaching;

    // Precache all of the assets generated by your build process.
    // Their URLs are injected into the manifest variable below.
    // This variable must be present somewhere in your service worker file,
    // even if you decide not to use precaching. See https://cra.link/PWA
    precacheAndRoute(self.__WB_MANIFEST || []);

    // --- Caching Strategies ---

    // 1. Static Assets (Cache First)
    // For CSS, JS, and Web Workers. Fast loading is key.
    registerRoute(
        ({ request }) => ['style', 'script', 'worker'].includes(request.destination),
        new CacheFirst({
            cacheName: 'static-assets',
        })
    );

    // 2. Fonts (Cache First)
    // Google Fonts and other fonts. They don't change often.
    registerRoute(
        ({ url }) => url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com',
        new CacheFirst({
            cacheName: 'google-fonts',
            plugins: [
                new ExpirationPlugin({ maxEntries: 20 }), // Cache up to 20 font files
                new CacheableResponsePlugin({ statuses: [0, 200] }),
            ],
        })
    );
    
    // 3. Media Files (Network First)
    // For images, audio, and video. Always try to get the latest version,
    // but fall back to the cached version if offline.
    registerRoute(
        ({ request }) => ['image', 'audio', 'video'].includes(request.destination),
        new NetworkFirst({
            cacheName: 'media-cache',
            plugins: [
                new CacheableResponsePlugin({
                    statuses: [0, 200], // Cache opaque responses (e.g., from R2)
                }),
                new ExpirationPlugin({
                    maxEntries: 60, // Keep up to 60 media files
                    maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
                    purgeOnQuotaError: true, // Auto-cleanup if storage quota is exceeded
                }),
            ],
        })
    );
    
    // 4. API Calls (Network First)
    // For the Firebase data. Always fetch the latest, but show stale content if offline.
    registerRoute(
        ({ url }) => url.pathname.startsWith('/api/saywith/'),
        new NetworkFirst({
            cacheName: 'api-cache',
            plugins: [
                new ExpirationPlugin({
                    maxEntries: 50,
                    maxAgeSeconds: 24 * 60 * 60, // 1 Day
                }),
                new CacheableResponsePlugin({
                    statuses: [0, 200],
                }),
            ],
        })
    );

    // 5. App Pages (Stale-While-Revalidate)
    // For navigation. Show the cached page immediately for a fast UX,
    // then check for updates in the background.
    registerRoute(
      ({ request }) => request.mode === 'navigate',
      new StaleWhileRevalidate({
        cacheName: 'pages-cache',
        plugins: [
          new ExpirationPlugin({
            maxEntries: 30,
          }),
          new CacheableResponsePlugin({
            statuses: [0, 200],
          }),
        ],
      })
    );

} else {
    console.log(`Boo! Workbox didn't load ðŸ˜¬`);
}

self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});
